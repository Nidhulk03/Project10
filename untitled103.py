# -*- coding: utf-8 -*-
"""Untitled103.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BKgoV4y2EJW4qk1b0tFlZseE3mHNQWZ1
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np

#Visualizations
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_style("dark")
import squarify
import matplotlib

#for market basket analysis (using apriori)
from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules

#for preprocessing
from mlxtend.preprocessing import TransactionEncoder


#to print all the interactive output without resorting to print, not only the last result.
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = "all"

pip install squarify

data = pd.read_csv('/content/market basket .csv', sep=';',parse_dates=['Date'])
df.head()

data.shape

data.head()

data.tail()

data.shape

#lets verify whether nan is present in columns
'nan' in data.columns
#so its proved that nan is not in columns

data.head()

##Lets consider the top 20 items purchased freequently
r=data.sum(axis=0).sort_values(ascending=False)[:20]
#altering the figsize
plt.figure(figsize=(20,10))
s=sns.barplot(x=r.index,y=r.values)
s.set_xticklabels(s.get_xticklabels(), rotation=90)

# create a color palette, mapped to these values
my_values=r.values
cmap = matplotlib.cm.Blues
mini=min(my_values)
maxi=max(my_values)
norm = matplotlib.colors.Normalize(vmin=mini, vmax=maxi)
colors = [cmap(norm(value)) for value in my_values]


#treemap of top 20 frequent items
plt.figure(figsize=(10,10))
squarify.plot(sizes=r.values, label=r.index, alpha=.7,color=colors)
plt.title("Tree map of top 20 items")
plt.axis('off')

import csv

# Open the CSV file for reading
with open('/content/market basket .csv', 'r') as csv_file:
    # Create a CSV reader
    csv_reader = csv.reader(csv_file)

    for row in csv_reader:
        # Assuming the data is in a column that you want to convert to boolean
        # You can perform your own logic here to determine True or False
        # For example, if the column contains 'True' or 'False' strings
        # you can use something like:
        boolean_value = row[0].strip().lower() == 'true'

        # Now you can use the 'boolean_value' in your code

import pandas as pd

# Assuming 'data' is your original DataFrame with non-boolean values
# Replace non-zero values with 1, leave zeros as they are
data = data.applymap(lambda x: 1 if x != 0 else 0)

#let us return items and ietmsets with atleast 5% support:
freq_items=apriori(data,min_support=0.05,use_colnames=True)

freq_items

res=association_rules(freq_items,metric="lift",min_threshold=1.3)

res

frequent_itemsets = apriori(data, min_support = 0.05, use_colnames=True)
frequent_itemsets['length'] = frequent_itemsets['itemsets'].apply(lambda x: len(x))
frequent_itemsets

frequent_itemsets[ (frequent_itemsets['length'] == 2) &
                   (frequent_itemsets['support'] >= 0.01) ]

frequent_itemsets[ (frequent_itemsets['length'] == 1) &
                   (frequent_itemsets['support'] >= 0.01) ]

#Importing Libraries

from mlxtend.frequent_patterns import fpgrowth

#running the fpgrowth algorithm
res=fpgrowth(data,min_support=0.05,use_colnames=True)

res

res=association_rules(res,metric="lift",min_threshold=1)

res

import time
l=[0.01,0.02,0.03,0.04,0.05]
t=[]
for i in l:
    t1=time.time()
    apriori(data,min_support=i,use_colnames=True)
    t2=time.time()
    t.append((t2-t1)*1000)

sns.lineplot(x=l,y=f,label="fpgrowth")
sns.lineplot(x=l,y=t,label="apriori")
plt.xlabel("Min_support Threshold")
plt.ylabel("Run Time in ms")